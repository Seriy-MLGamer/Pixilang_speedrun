/*
(C) 2023 Серый MLGamer. Все свободы предоставлены.
Видео в Дзене: <https://dzen.ru/seriy_mlgamer>
Музыка на SoundCloud: <https://soundcloud.com/seriy_mlgamer>
Видео на YouTube: <https://www.youtube.com/@Seriy_MLGamer>
Код на GitHub: <https://github.com/Seriy-MLGamer>
Страница ВКонтакте: <https://vkontakte.ru/seriy_mlgamer>
Материальная поддержка в DonationAlerts: <https://www.donationalerts.com/r/seriy_mlgamer>
Электронная почта: <Seriy-MLGamer@yandex.ru>

Этот файл - часть Супербыстрой сортировки.
Супербыстрая сортировка - свободная программа: вы можете перераспространять её и/или изменять её на условиях Стандартной общественной лицензии GNU в том виде, в каком она была опубликована Фондом свободного программного обеспечения; либо версии 3 лицензии, либо (по вашему выбору) любой более поздней версии.
Супербыстрая сортировка распространяется в надежде, что она будет полезна, но БЕЗО ВСЯКИХ ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЁННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной общественной лицензии GNU.
Вы должны были получить копию Стандартной общественной лицензии GNU вместе с этой программой. Если это не так, см. <https://www.gnu.org/licenses/>.
*/

/**
 * @file quick sort.pixi
 * В этом файле содержится код алгоритма быстрой сортировки.
 * Подробнее об алгоритме: https://ru.wikipedia.org/wiki/Быстрая_сортировка
 */

include "render.pixi" //Подключаем код алгоритма отрисовки контейнера.

/**
 * Алгоритм быстрой сортировки. Способен сортировать числовые контейнеры в порядке возрастания в среднем за время O(n*log(n)).
 * @param $container числовой контейнер.
 * @param $first первый элемент контейнера; смещение обрабатываемой области от начала контейнера. Необязательный аргумент. По умолчанию равен 0.
 * @param $count размер обрабатываемой области. Необязательный аргумент. По умолчанию равен get_size($container)-$first.
 */
fn quick_sort($container, $first, $count)
{
	//Передаём контейнер для отрисовки OpenGL-колбэком render().
	render_container=$container //Уберите эту строку, если хотите чистый алгоритм без графики.
	//Создаём отдельный "стек".
	/*
	Дело в том, что если сортировать с помощью рекурсивных вызовов функции для обработки подмассивов, то в худшем случае работы алгоритма глубина рекурсии будет равна размеру обрабатываемой области, что может привести к переполнению стека вызовов.
	Мой "стек" работает по-другому. Ну, это не стек в привычном смысле слова, а скорее его срез. В нём хранится информация о подмассивах. За одну итерацию обрабатывается один уровень рекурсии в соответствии с информацией из "стека". В результате получается информация о следующем уровне рекурсии.
	Таким образом мой "стек" - срез настоящего стека - способен существовать без него. Это позволяет защитить алгоритм от переполнения стека.
	*/
	$stack=new(2, 1, INT) /**"Стек".*/
	//Если аргумент $first не задан (количество переданных аргументов функции (переменная $0) меньше 2), то начальным элементом контейнера будет значение по умолчанию.
	if $0<2
	{
		$stack[0, 0]=0
	}
	else
	{
		$stack[0, 0]=$first
	}
	//Если аргумент $count не задан (количество переданных аргументов функции (переменная $0) меньше 3), то конечным элементом контейнера будет его конец.
	if $0<3
	{
		$stack[1, 0]=get_size($container)
	}
	else
	{
		$stack[1, 0]=$first+$count
	}
	$stack_size=1
	//А вот и сам алгоритм.
	while $stack_size
	{
		$new_stack=new(2, 1, INT) /**Новый "стек" для сбора информации о следующем уровне рекурсии.*/
		$new_stack_size=0
		//Обработка подмассивов, заданных в "стеке".
		for ($a=0; $a!=$stack_size; $a+1)
		{
			/**Опорное значение, относительно которого будет происходить разделение.*/
			$pivot=($container[$stack[0, $a]]+$container[$stack[1, $a]-1])/2
			$left=$stack[0, $a]
			$right=$stack[1, $a]
			$changed=0 /**Этот параметр выглядит костыльным, но, тем не менее, без него сортируется неправильно.*/
			//Это алгоритм разделения - одна из важнейших составляющих алгоритма быстрой сортировки.
			/*
			Идём слева направо. Если значение ячейки под индексом $left на пути больше опорного значения или равно ему, то происходит обмен с правой ячейкой под индексом $right, затем этот индекс уменьшается в знак увеличения количества элементов в правой части. Иначе без обмена увеличивается количество элементов в левой части, индекс $left увеличивается.
			По завершении алгоритма в левой части будут элементы меньше опорного, а в правой - больше него или равные ему.
			*/
			while $left!=$right
			{
				if $container[$left]>=$pivot
				{
					$right-1
					//Переменная $changed меняется только при изменении.
					if $container[$left]!=$container[$right]
					{
						$temp=$container[$left] /**Для обмена значений нужна дополнительная переменная.*/
						$container[$left]=$container[$right]
						$container[$right]=$temp
						$changed=1
					}
				}
				else
				{
					$left+1
				}
				//Передаём стек для отрисовки OpenGL-колбэком render().
				render_stack=$stack //Уберите эту строку, если хотите чистый алгоритм без графики.
				//Отрисовка!
				frame() //Уберите эту строку, если хотите чистый алгоритм без графики.
			}
			//Теперь находим подмассивы и добавляем информацю о них в новый "стек". И это вторая составляющая алгоритма быстрой сортировки. Всё. Остальное - приправы.
			/*
			Объясню смысл переменной $changed.
			Если индекс $right постоянно уменьшался, а индекс $left оставался равным левой границе подмассива ($stack[0, $a]), это значит, что в подмассиве все элементы не меньше опорного значения, то есть это значение является наименьшим. Но это не всегда значит, что подмассив является отсортированным. И если подмассив после разделения не отличается от подмассива до разделения, это также не всегда значит, что он является таким.
			Но если индекс $right стал равен $stack[0, $a] и не изменился подмассив, то есть $changed равен 0, то подмассив состоит из одинаковых элементов, а значит является отсортированным. Иначе его нужно пустить ещё по одному кругу, пока всё не выяснится.
			*/
			if $changed||$right!=$stack[0, $a]
			{
				//Добавляем информацию о левом подмассиве в новый "стек", если его размер не меньше 2.
				if $right>$stack[0, $a]+1
				{
					resize($new_stack, 2, $new_stack_size+1)
					$new_stack[0, $new_stack_size]=$stack[0, $a]
					$new_stack[1, $new_stack_size]=$right
					$new_stack_size+1
				}
				//Добавляем информацию о правом подмассиве в новый "стек", если его размер не меньше 2.
				if $stack[1, $a]>$right+1
				{
					resize($new_stack, 2, $new_stack_size+1)
					$new_stack[0, $new_stack_size]=$right
					$new_stack[1, $new_stack_size]=$stack[1, $a]
					$new_stack_size+1
				}
			}
		}
		//Меняем старый "стек" на новый.
		remove($stack)
		$stack=$new_stack
		$stack_size=$new_stack_size
	}
	//Алгоритм почти завершился. Теперь нужно убрать за собой.
	remove($stack)
}